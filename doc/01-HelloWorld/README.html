<!DOCTYPE html>
<html>
  <head>
    <title>gRPC C++ Hello World Tutorial</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link type="text/css" rel="stylesheet" href="assets/style.css" />
    <link type="text/css" rel="stylesheet" href="assets/pilcrow.css" />
    <link type="text/css" rel="stylesheet" href="assets/hljs-github.min.css"/>
  </head>
<body><h1 id="grpc-c++-hello-world-tutorial"><a class="header-link" href="#grpc-c++-hello-world-tutorial"></a>gRPC C++ Hello World Tutorial</h1>
<h3 id="install-grpc"><a class="header-link" href="#install-grpc"></a>Install gRPC</h3>
<p>Make sure you have installed gRPC on your system. Follow the instructions here:
<a href="../../../INSTALL.html">https://github.com/grpc/grpc/blob/master/INSTALL</a>.</p>
<h3 id="get-the-tutorial-source-code"><a class="header-link" href="#get-the-tutorial-source-code"></a>Get the tutorial source code</h3>
<p>The example code for this and our other examples lives in the <code>examples</code>
directory. Clone this repository to your local machine by running the
following command:</p>
<pre class="hljs"><code>$ git <span class="hljs-built_in">clone</span> -b $(curl -L https://grpc.io/release) https://github.com/grpc/grpc</code></pre><p>Change your current directory to examples/cpp/helloworld</p>
<pre class="hljs"><code>$ <span class="hljs-built_in">cd</span> examples/cpp/helloworld/</code></pre><h3 id="defining-a-service"><a class="header-link" href="#defining-a-service"></a>Defining a service</h3>
<p>The first step in creating our example is to define a <em>service</em>: an RPC
service specifies the methods that can be called remotely with their parameters
and return types. As you saw in the
<a href="#protocolbuffers">overview</a> above, gRPC does this using <a href="https://developers.google.com/protocol-buffers/docs/overview">protocol
buffers</a>. We
use the protocol buffers interface definition language (IDL) to define our
service methods, and define the parameters and return
types as protocol buffer message types. Both the client and the
server use interface code generated from the service definition.</p>
<p>Here&#39;s our example service definition, defined using protocol buffers IDL in
<a href="../../protos/helloworld.proto">helloworld.proto</a>. The <code>Greeting</code>
service has one method, <code>hello</code>, that lets the server receive a single
<code>HelloRequest</code>
message from the remote client containing the user&#39;s name, then send back
a greeting in a single <code>HelloReply</code>. This is the simplest type of RPC you
can specify in gRPC - we&#39;ll look at some other types later in this document.</p>
<pre class="hljs"><code>syntax = <span class="hljs-string">"proto3"</span>;

<span class="hljs-keyword">option</span> java_package = <span class="hljs-string">"ex.grpc"</span>;

<span class="hljs-keyword">package</span> helloworld;

<span class="hljs-comment">// The greeting service definition.</span>
<span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">Greeter</span> </span>{
  <span class="hljs-comment">// Sends a greeting</span>
  <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello (HelloRequest) <span class="hljs-keyword">returns</span> (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1</span>;
}

<span class="hljs-comment">// The response message containing the greetings</span>
<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">HelloReply</span> </span>{
  <span class="hljs-built_in">string</span> <span class="hljs-class"><span class="hljs-keyword">message</span> = 1;
}</span></code></pre><p><a name="generating"></a></p>
<h3 id="generating-grpc-code"><a class="header-link" href="#generating-grpc-code"></a>Generating gRPC code</h3>
<p>Once we&#39;ve defined our service, we use the protocol buffer compiler
<code>protoc</code> to generate the special client and server code we need to create
our application. The generated code contains both stub code for clients to
use and an abstract interface for servers to implement, both with the method
defined in our <code>Greeting</code> service.</p>
<p>To generate the client and server side interfaces:</p>
<pre class="hljs"><code>$ make helloworld.grpc.pb.cc helloworld.pb.cc</code></pre><p>Which internally invokes the proto-compiler as:</p>
<pre class="hljs"><code>$ protoc -I ../../protos/ --grpc_out=. --plugin=protoc-gen-grpc=grpc_cpp_plugin ../../protos/helloworld.proto
$ protoc -I ../../protos/ --cpp_out=. ../../protos/helloworld.proto</code></pre><h3 id="writing-a-client"><a class="header-link" href="#writing-a-client"></a>Writing a client</h3>
<ul class="list">
<li><p>Create a channel. A channel is a logical connection to an endpoint. A gRPC
channel can be created with the target address, credentials to use and
arguments as follows</p>
<pre class="hljs"><code>  <span class="hljs-keyword">auto</span> channel = CreateChannel(<span class="hljs-string">"localhost:50051"</span>, InsecureChannelCredentials());</code></pre></li>
<li><p>Create a stub. A stub implements the rpc methods of a service and in the
generated code, a method is provided to created a stub with a channel:</p>
<pre class="hljs"><code>  <span class="hljs-keyword">auto</span> stub = helloworld::Greeter::NewStub(channel);</code></pre></li>
<li><p>Make a unary rpc, with <code>ClientContext</code> and request/response proto messages.</p>
<pre class="hljs"><code>  ClientContext context;
  HelloRequest request;
  request.set_name(<span class="hljs-string">"hello"</span>);
  HelloReply reply;
  Status status = stub-&gt;SayHello(&amp;context, request, &amp;reply);</code></pre></li>
<li><p>Check returned status and response.</p>
<pre class="hljs"><code>  <span class="hljs-keyword">if</span> (status.ok()) {
    <span class="hljs-comment">// check reply.message()</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// rpc failed.</span>
  }</code></pre></li>
</ul>
<p>For a working example, refer to <a href="greeter_client.cc">greeter_client.cc</a>.</p>
<h3 id="writing-a-server"><a class="header-link" href="#writing-a-server"></a>Writing a server</h3>
<ul class="list">
<li><p>Implement the service interface</p>
<pre class="hljs"><code>  <span class="hljs-keyword">class</span> GreeterServiceImpl final : <span class="hljs-keyword">public</span> Greeter::Service {
    <span class="hljs-function">Status <span class="hljs-title">SayHello</span><span class="hljs-params">(ServerContext* context, <span class="hljs-keyword">const</span> HelloRequest* request,
        HelloReply* reply)</span> override </span>{
      <span class="hljs-built_in">std</span>::<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">prefix</span><span class="hljs-params">(<span class="hljs-string">"Hello "</span>)</span></span>;
      reply-&gt;set_message(prefix + request-&gt;name());
      <span class="hljs-keyword">return</span> Status::OK;
    }
  };</code></pre></li>
<li><p>Build a server exporting the service</p>
<pre class="hljs"><code>  GreeterServiceImpl service;
  ServerBuilder builder;
  builder.AddListeningPort(<span class="hljs-string">"0.0.0.0:50051"</span>, grpc::InsecureServerCredentials());
  builder.RegisterService(&amp;service);
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Server&gt; server(builder.BuildAndStart());</code></pre></li>
</ul>
<p>For a working example, refer to <a href="greeter_server.cc">greeter_server.cc</a>.</p>
<h3 id="writing-asynchronous-client-and-server"><a class="header-link" href="#writing-asynchronous-client-and-server"></a>Writing asynchronous client and server</h3>
<p>gRPC uses <code>CompletionQueue</code> API for asynchronous operations. The basic work flow
is</p>
<ul class="list">
<li>bind a <code>CompletionQueue</code> to a rpc call</li>
<li>do something like a read or write, present with a unique <code>void*</code> tag</li>
<li>call <code>CompletionQueue::Next</code> to wait for operations to complete. If a tag
appears, it indicates that the corresponding operation is complete.</li>
</ul>
<h4 id="async-client"><a class="header-link" href="#async-client"></a>Async client</h4>
<p>The channel and stub creation code is the same as the sync client.</p>
<ul class="list">
<li><p>Initiate the rpc and create a handle for the rpc. Bind the rpc to a
<code>CompletionQueue</code>.</p>
<pre class="hljs"><code>  CompletionQueue cq;
  <span class="hljs-keyword">auto</span> rpc = stub-&gt;AsyncSayHello(&amp;context, request, &amp;cq);</code></pre></li>
<li><p>Ask for reply and final status, with a unique tag</p>
<pre class="hljs"><code>  Status status;
  rpc-&gt;Finish(&amp;reply, &amp;status, (<span class="hljs-keyword">void</span>*)<span class="hljs-number">1</span>);</code></pre></li>
<li><p>Wait for the completion queue to return the next tag. The reply and status are
ready once the tag passed into the corresponding <code>Finish()</code> call is returned.</p>
<pre class="hljs"><code>  <span class="hljs-keyword">void</span>* got_tag;
  <span class="hljs-keyword">bool</span> ok = <span class="hljs-literal">false</span>;
  cq.Next(&amp;got_tag, &amp;ok);
  <span class="hljs-keyword">if</span> (ok &amp;&amp; got_tag == (<span class="hljs-keyword">void</span>*)<span class="hljs-number">1</span>) {
    <span class="hljs-comment">// check reply and status</span>
  }</code></pre></li>
</ul>
<p>For a working example, refer to <a href="greeter_async_client.cc">greeter_async_client.cc</a>.</p>
<h4 id="async-server"><a class="header-link" href="#async-server"></a>Async server</h4>
<p>The server implementation requests a rpc call with a tag and then wait for the
completion queue to return the tag. The basic flow is</p>
<ul class="list">
<li><p>Build a server exporting the async service</p>
<pre class="hljs"><code>  helloworld::Greeter::AsyncService service;
  ServerBuilder builder;
  builder.AddListeningPort(<span class="hljs-string">"0.0.0.0:50051"</span>, InsecureServerCredentials());
  builder.RegisterService(&amp;service);
  <span class="hljs-keyword">auto</span> cq = builder.AddCompletionQueue();
  <span class="hljs-keyword">auto</span> server = builder.BuildAndStart();</code></pre></li>
<li><p>Request one rpc</p>
<pre class="hljs"><code>  ServerContext context;
  HelloRequest request;
  ServerAsyncResponseWriter&lt;HelloReply&gt; responder;
  service.RequestSayHello(&amp;context, &amp;request, &amp;responder, &amp;cq, &amp;cq, (<span class="hljs-keyword">void</span>*)<span class="hljs-number">1</span>);</code></pre></li>
<li><p>Wait for the completion queue to return the tag. The context, request and
responder are ready once the tag is retrieved.</p>
<pre class="hljs"><code>  HelloReply reply;
  Status status;
  <span class="hljs-keyword">void</span>* got_tag;
  <span class="hljs-keyword">bool</span> ok = <span class="hljs-literal">false</span>;
  cq.Next(&amp;got_tag, &amp;ok);
  <span class="hljs-keyword">if</span> (ok &amp;&amp; got_tag == (<span class="hljs-keyword">void</span>*)<span class="hljs-number">1</span>) {
    <span class="hljs-comment">// set reply and status</span>
    responder.Finish(reply, status, (<span class="hljs-keyword">void</span>*)<span class="hljs-number">2</span>);
  }</code></pre></li>
<li><p>Wait for the completion queue to return the tag. The rpc is finished when the
tag is back.</p>
<pre class="hljs"><code>  <span class="hljs-keyword">void</span>* got_tag;
  <span class="hljs-keyword">bool</span> ok = <span class="hljs-literal">false</span>;
  cq.Next(&amp;got_tag, &amp;ok);
  <span class="hljs-keyword">if</span> (ok &amp;&amp; got_tag == (<span class="hljs-keyword">void</span>*)<span class="hljs-number">2</span>) {
    <span class="hljs-comment">// clean up</span>
  }</code></pre></li>
</ul>
<p>To handle multiple rpcs, the async server creates an object <code>CallData</code> to
maintain the state of each rpc and use the address of it as the unique tag. For
simplicity the server only uses one completion queue for all events, and runs a
main loop in <code>HandleRpcs</code> to query the queue.</p>
<p>For a working example, refer to <a href="greeter_async_server.cc">greeter_async_server.cc</a>.</p>
</body>
</html>
